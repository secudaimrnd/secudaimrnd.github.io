---
title: '[시스템 해킹] [FTZ] level10 | 공유 메모리'
author: cotes
date: 2023-02-09 23:35:00 +0900
categories: [Computer Science, System Hacking | Pwnable] 
tags: [study]
math: true
mermaid: true
pin: true
---
# level10 | 공유 메모리

### **What to Study**

- 공유 메모리
- IPC
- shmget, shmat, shmdt
- IPC_CREAT | 0666
- 공유 메모리와 관련된 명령어 ipcs

### 문제

```bash
[level10@ftz tmp]$ cat ../hint 

두명의 사용자가 대화방을 이용하여 비밀스런 대화를 나누고 있다.
그 대화방은 공유 메모리를 이용하여 만들어졌으며, 
key_t의 값은 7530이다. 이를 이용해 두 사람의 대화를 도청하여 
level11의 권한을 얻어라.

- 레벨을 완료하셨다면 소스는 지우고 나가주세요.
```

### 공유 메모리란?

![Untitled](level10%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20ed141181fb5c4159b41f4f0df76bc0bc/Untitled.png)

### 문제 분석

```bash
[level10@ftz level10]$ find / -user level10 2>/dev/null
# ????  관련 내용 접근 불가 또는 없음 

[level10@ftz level10]$ ls -al # 실행 내역 확인
total 84
drwxr-xr-x    5 root     level10      4096 Jan 14  2010 ./
drwxr-xr-x   34 root     root         4096 Sep 10  2011 ../
-rw-------    1 root     root            1 Jan 15  2010 .bash_history
-rw-r--r--    1 root     root           24 Feb 24  2002 .bash_logout
-rw-r--r--    1 root     root          224 Feb 24  2002 .bash_profile
-rw-r--r--    1 root     root          151 Feb 24  2002 .bashrc
-rw-r--r--    1 root     root          400 Sep 24  2000 .cshrc
-rw-r--r--    1 root     root         4742 Sep 24  2000 .emacs
-r--r--r--    1 root     root          319 Sep 24  2000 .gtkrc
-rw-r--r--    1 root     root          100 Sep 24  2000 .gvimrc
-rw-r-----    1 root     level10       253 Jan 14  2010 hint
-rw-r--r--    1 root     root          226 Sep 24  2000 .muttrc
-rw-r--r--    1 root     root          367 Sep 24  2000 .profile
drwxr-x---    2 root     root         4096 Mar 29  2003 program/
drwxr-xr-x    2 root     level10      4096 Feb 24  2002 public_html/
drwxrwxr-x    2 root     level10      4096 Feb  9 19:34 tmp/
-rw-------    1 root     root            1 May  7  2002 .viminfo
-rw-r--r--    1 root     root         4145 Sep 24  2000 .vimrc
-rw-r--r--    1 root     root          245 Sep 24  2000 .Xdefaults
```

```bash
[level10@ftz level10]$ cat /etc/rc.d/rc.local // 시작 프로그램 
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.

touch /var/lock/subsys/local

# setting hostname
hostname ftz.hackerschool.org

# run web server
/etc/init.d/httpd start

# open level4 port
cp /bin/ls /home/level4/tmp/backdoor
chown level4.level4 /home/level4/tmp/backdoor
/etc/init.d/xinetd restart
rm -rf /home/level4/tmp/backdoor

# run level10
/home/level10/program/level10 // linux 구동 시 level10 폴더로 

# get ip
dhclient eth0
```

```bash
[level10@ftz tmp]$ ps -ef | grep level10
level10  30892 30890  0 19:36 ?        00:00:00 [sshd]
level10  30893 30892  0 19:36 pts/0    00:00:00 -bash
level10  30928  1884  0 19:37 tty1     00:00:00 -bash
level10  31011 30893  0 19:48 pts/0    00:00:00 ps -ef
level10  31012 30893  0 19:48 pts/0    00:00:00 grep level10
```

- 공유 메모리 확인

```bash
[level10@ftz tmp]$ ipcs

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status      
0x00001d6a 0          root      666        1028       0                       
0x46532e4f 32769      trainer3  777        5          0                       

------ Semaphore Arrays --------
key        semid      owner      perms      nsems     

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
```

```bash
[level10@ftz tmp]$ printf %d 0x00001d6a      
7530
```

- 0x00001d6a  → 7530

- 공유 메모리 접근 코드 작성

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFSIZE 1024

int main() 
{
        void *sharedMemory = (void *)0;
        int sharedMemId;
        char buf[BUFSIZE];
        key_t keyval = 7530;

				//  BUFSIZE 만큼 공유 메모리 생성
        sharedMemID = shmget(keyval, BUFSIZE, IPC_CREAT | 0666);

				// 프로세스에서 공유 메모리 공간을 사용할 수 있게 attach 함
        sharedMemory = shmat(sharedMemID, (void *)0, 0);

				// 공유 메모리 공간에 있는 값을 buf에 복사
        memcpy(sharedMemory, buf, BUFSIZE);
        printf("%s", sharedMemory);

				// 프로세스에서 공유 메모리의 연결을 분리
        shmdt(sharedMemory);

        return 0;
}
```

- 컴파일 후 실행

```c
[level10@ftz tmp]$ gcc -o level10 level10.c
[level10@ftz tmp]$ ./level10
멍멍: level11의 패스워드는?
구타: what!@#$?
```

( 참고로 이 결과는 퍼왔습니다.. 열심히 따라 했으나.. 모종의 이유로.. 결과가 나오지 않았습니다.. )

### 공유 메모리 관련 함수

```c
int shmget(key_t argument_key, size_t size, int shmflg);

argument_key와 관련된 공유 메모리 segment의 id를 반환한다.
shmflg에 따라 적절하게 값을 반환한다.

shmflg의 종류
- IPC_CREAT : 새로운 메모리 segment 만듬. 
              참고로 0666은 파일의 기본 권한을 설정한다.
- IPC_EXCL : 메모리가 사용 중인지 확인 후, 없으면 IPC_CREAT를 통해 할당. NULL체크와 비슷한 개념
```

```c
void *shmat(int shmid, const void *shmaddr, int shmflg);

공유 메모리를 얻었다면, shmget으로 얻은 shmid에 프로세스를 attach하는 시스템 콜.
shmaddr가 NULL(0)일 경우, 적절한 주소 값을 반환.
NULL(0)이 아닐 경우, 그 주소와 가장 가까운 주소를 반환.
에러 발생 시 -1 반환한다. void *로 반환한다.
```

```c
int shmdt(const void *shmaddr);
공유 메모리와 프로세스를 떼어낸다. shmaddr에는 shmat으로 받은 주소를 넣는다. 
성공 시 0, 실패 시 -1을 반환한다.
```

```c
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
공유 메모리를 제어하기 위해 사용한다.
정보를 얻거나, 어떤 값을 쓰거나, 공유 메모리를 삭제하는 등의 조작을 위한 함수.

cmd : 공유 메모리에 실행할 command
```

```c
struct shmid_ds {
                 struct    ipc_perm shm_perm;  /* operation perms */
                 int  shm_segsz;          /* size of segment (bytes) */
                 time_t    shm_atime;          /* last attach time */
                 time_t    shm_dtime;          /* last detach time */
                 time_t    shm_ctime;          /* last change time */
                 unsigned short shm_cpid; /* pid of creator */
                 unsigned short shm_lpid; /* pid of last operator */
                 short     shm_nattch;         /* no. of current attaches */
            };

```

```c
struct ipc_perm {
              key_t  key;
              ushort uid;   /* owner euid and egid */
              ushort gid;
              ushort cuid;  /* creator euid and egid */
              ushort cgid;
              ushort mode;  /* lower 9 bits of shmflg */
              ushort seq;   /* sequence number */
            };
```

### 프로세스 간 통신  (IPC, Inter Process Communication)

![Untitled](level10%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20ed141181fb5c4159b41f4f0df76bc0bc/Untitled%201.png)

<aside>
💡 프로세스 간 서로 데이터를 주고받는 행위, 그에 대한 방법이나 경로를 뜻함

</aside>

- 주요 IPC 방식
    - 파일
    - 신호
    - 소켓
    - 메시지 큐
    - 파이프
    - 지명 파이프
    - 세마 포어
    - **공유 메모리**
    - 메시지 전달
    - 메모리 맵 파일
    
    **📎 [wikipedia | 프로세스 간 통신](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B0%84_%ED%86%B5%EC%8B%A0)** 참고
    

### ASSEMBLY

```bash
(gdb) disas main
Dump of assembler code for function main:
0x080483f8 <main+0>:    push   %ebp
0x080483f9 <main+1>:    mov    %esp,%ebp
0x080483fb <main+3>:    sub    $0x428,%esp
0x08048401 <main+9>:    and    $0xfffffff0,%esp
0x08048404 <main+12>:   mov    $0x0,%eax
0x08048409 <main+17>:   sub    %eax,%esp
0x0804840b <main+19>:   movl   $0x0,0xfffffff4(%ebp)
0x08048412 <main+26>:   movl   $0x1d6a,0xfffffbe4(%ebp)
0x0804841c <main+36>:   sub    $0x4,%esp
0x0804841f <main+39>:   push   $0x3b6
0x08048424 <main+44>:   push   $0x400
0x08048429 <main+49>:   pushl  0xfffffbe4(%ebp)
0x0804842f <main+55>:   call   0x80482e8 <shmget>
0x08048434 <main+60>:   add    $0x10,%esp
0x08048437 <main+63>:   mov    %eax,0xfffffff0(%ebp)
0x0804843a <main+66>:   sub    $0x4,%esp
0x0804843d <main+69>:   push   $0x0
0x0804843f <main+71>:   push   $0x0
0x08048441 <main+73>:   pushl  0xfffffff0(%ebp)
0x08048444 <main+76>:   call   0x8048338 <shmat>
0x08048449 <main+81>:   add    $0x10,%esp
0x0804844c <main+84>:   mov    %eax,0xfffffff4(%ebp)
0x0804844f <main+87>:   sub    $0x4,%esp
0x08048452 <main+90>:   push   $0x400
0x08048457 <main+95>:   lea    0xfffffbe8(%ebp),%eax
0x0804845d <main+101>:  push   %eax
0x0804845e <main+102>:  pushl  0xfffffff4(%ebp)
0x08048461 <main+105>:  call   0x8048328 <memcpy>
0x08048466 <main+110>:  add    $0x10,%esp
0x08048469 <main+113>:  sub    $0x8,%esp
0x0804846c <main+116>:  pushl  0xfffffff4(%ebp)
0x0804846f <main+119>:  push   $0x8048540
0x08048474 <main+124>:  call   0x8048318 <printf>
0x08048479 <main+129>:  add    $0x10,%esp
0x0804847c <main+132>:  sub    $0xc,%esp
0x0804847f <main+135>:  pushl  0xfffffff4(%ebp)
0x08048482 <main+138>:  call   0x80482f8 <shmdt>
0x08048487 <main+143>:  add    $0x10,%esp
0x0804848a <main+146>:  mov    $0x0,%eax
0x0804848f <main+151>:  leave  
0x08048490 <main+152>:  ret    
0x08048491 <main+153>:  nop    
0x08048492 <main+154>:  nop    
0x08048493 <main+155>:  nop
```

- push
    - stack에 data 저장
    - 사용법
    
    ```c
    push eax // 스택에 데이터를 저장하는데 많이 쓰임
    push 20 // 즉석값인 20을 stack에 저장
    push 401F47 // 
    ```
    
- mov
- sub
- and
- movl
- pushl
- call
- add
- lea
- leave
- ret
